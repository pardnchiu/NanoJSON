const $window = window; const $document = document; const $String = String; const $Number = Number; const $Boolean = Boolean; const $Array = Array; const $Object = Object; const $DocumentFragment = DocumentFragment; const $Blob = Blob; const $URL = URL; const $Math = Math; const $Date = Date; const $setTimeout = setTimeout; const $JSON = JSON; const $confirm = confirm; const $parseFloat = parseFloat; const $isNaN = isNaN; const $FileReader = FileReader; const $File = File; const $fetch = fetch; const $Promise = Promise; const regexCssClass = /\.([\w_-]+)?/gi; const regexCssID = /\#([\w_-]+)?/i; const regexCssTag = /^\w+(?=[\#\.]*)/i; const htmlBr = "<br>"; const _name = "name"; const _text = "text"; const _catch = "catch"; const _then = "then"; const _readAsText = "readAsText"; const _createObjectURL = "createObjectURL"; const _revokeObjectURL = "revokeObjectURL"; const _removeChild = "removeChild"; const _click = "click"; const _onload = "onload"; const _parse = "parse"; const _true = "true"; const _false = "false"; const _add = "add"; const _appendChild = "appendChild"; const _class = "class"; const _section = "section"; const _focus = "focus"; const _key = "key"; const _stringify = "stringify"; const _label = "label"; const _Color = "Color"; const _target = "target"; const _color = "color"; const _fill = "fill"; const _entries = "entries"; const _insert = "insert"; const _collapseable = "collapseable"; const _createDocumentFragment = "createDocumentFragment"; const _contentEditable = "contentEditable"; const _replaceChildren = "replaceChildren"; const _toLowerCase = "toLowerCase"; const _beforeRender = "beforeRender"; const _beforeUpdate = "beforeUpdate"; const _beforeDestroy = "beforeDestroy"; const _rendered = "rendered"; const _updated = "updated"; const _button = "button"; const _destroyed = "destroyed"; const _type = "type"; const _script = "script"; const _createTextNode = "createTextNode"; const _console = "console"; const _onchange = "onchange"; const _oninput = "oninput"; const _log = "log"; const _body = "body"; const _apply = "apply"; const _src = "src"; const _void = "void"; const _title = "title"; const _description = "description"; const _error = "error"; const _now = "now"; const _render = "render"; const _when = "when"; const _remove = "remove"; const _random = "random"; const _create = "create"; const _dataset = "dataset"; const _display = "display"; const _float = "float"; const _has = "has"; const "dom" = "dom"; const _floor = "floor"; const _input = "input"; const _charAt = "charAt"; const _textarea = "textarea"; const _height = "height"; const _img = "img"; const _parent = "parent"; const _onclick = "onclick"; const _index = "index"; const _inner = "inner"; const _isArray = "isArray"; const _length = "length"; const _map = "map"; const _match = "match"; const _number = "number"; const _object = "object"; const _replace = "replace"; const _keys = "keys"; const _placeholder = "placeholder"; const _set = "set"; const _source = "source"; const _style = "style"; const _string = "string"; const _select = "select"; const _selected = "selected"; const _checked = "checked"; const _background = "background"; const _option = "option"; const _temp = "temp"; const _test = "test"; const _textContent = "textContent"; const _trim = "trim"; const _update = "update"; const _value = "value"; const _width = "width"; const _collapsed = "collapsed"; const _array = "array"; const _boolean = "boolean"; const _reset = "reset"; const _import = "import"; const _export = "export"; const _children = "children"; const _splice = "splice"; const _push = "push"; const _editor = "editor"; const _getElementById = "getElementById"; const _nextElementSibling = "nextElementSibling"; const "link" = "link"; const _rel = "rel"; const _preconnect = "preconnect"; const _href = "href"; const _crossOrigin = "crossOrigin"; const _preload = "preload"; const _as = "as"; const _anonymous = "anonymous"; const _head = "head"; const _backgroundColor = "background" + _Color; const _classList = _class + "List"; const _createElement = _create + "Element"; const _hasOwnProperty = _has + "OwnProperty"; const _indexOf = _index + "Of"; const _innerHTML = _inner + "HTML"; const _innerText = _inner + "Text"; const _setAttribute = _set + "Attribute"; const types = [_string, _number, _boolean, _array, _object]; const css = "https://cdn.jsdelivr.net/npm/@pardnchiu/nanojson@0.3.4/dist/NanoJSON.css"; const copyright = `NanoJSON\nGitHub: https://github.com/pardnchiu/NanoJSON\nCreator: Pardn Chiu\nLicense: Proprietary`; const copyright_style = `line-height: 1.75rem; font-size: 0.875rem;`; const lifecycleAction = { [_beforeRender]: _beforeRender, [_beforeUpdate]: _beforeUpdate, [_beforeDestroy]: _beforeDestroy, [_rendered]: _rendered, [_updated]: _updated, [_destroyed]: _destroyed }; for (let e of [createElement("link", { [_rel]: "preconnect", [_href]: "https://cdn.jsdelivr.net" }), createElement("link", { [_rel]: _preload, [_href]: css, [_as]: _style }), createElement("link", { [_rel]: "stylesheet", [_href]: css })]) { $document[_head][_appendChild](e) } document.addEventListener("DOMContentLoaded", (_ => { printLog("%c" + copyright, copyright_style) })); const icon = { number: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5.5 15v-4.5H4V9h3v6H5.5zM9 15v-2.5c0-.283.096-.52.287-.713A.967.967 0 0110 11.5h2v-1H9V9h3.5c.283 0 .52.096.713.287.191.192.287.43.287.713v1.5c0 .283-.096.52-.287.713a.968.968 0 01-.713.287h-2v1h3V15H9zm6 0v-1.5h3v-1h-2v-1h2v-1h-3V9h3.5c.283 0 .52.096.712.287.192.192.288.43.288.713v4c0 .283-.096.52-.288.713A.968.968 0 0118.5 15H15z" fill="#5F6368"/></svg>`, string: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 15a.968.968 0 01-.712-.287A.968.968 0 0116 14v-4c0-.283.096-.52.288-.713A.968.968 0 0117 9h3c.283 0 .52.096.712.287.192.192.288.43.288.713v1h-1.5v-.5h-2v3h2V13H21v1c0 .283-.096.52-.288.713A.968.968 0 0120 15h-3zm-7.5 0V9h4c.283 0 .52.096.713.287.191.192.287.43.287.713v1c0 .283-.096.52-.287.713A.968.968 0 0113.5 12c.283 0 .52.096.713.287.191.192.287.43.287.713v1c0 .283-.096.52-.287.713A.968.968 0 0113.5 15h-4zm1.5-3.75h2v-.75h-2v.75zm0 2.25h2v-.75h-2v.75zM3 15v-5c0-.283.096-.52.288-.713A.968.968 0 014 9h3c.283 0 .52.096.713.287.191.192.287.43.287.713v5H6.5v-1.5h-2V15H3zm1.5-3h2v-1.5h-2V12z" fill="#5F6368"/></svg>`, object: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.5 18v-1.5h2.25c.213 0 .39-.072.534-.216a.726.726 0 00.216-.534v-1.5c0-.475.137-.906.413-1.294A2.233 2.233 0 0118 12.131v-.262a2.233 2.233 0 01-1.087-.825A2.184 2.184 0 0116.5 9.75v-1.5a.726.726 0 00-.216-.534.726.726 0 00-.534-.216H13.5V6h2.25a2.17 2.17 0 011.594.656c.437.438.656.969.656 1.594v1.5c0 .213.072.39.216.534a.726.726 0 00.534.216h.75v3h-.75a.726.726 0 00-.534.216.726.726 0 00-.216.534v1.5a2.17 2.17 0 01-.656 1.594A2.17 2.17 0 0115.75 18H13.5zm-5.25 0a2.17 2.17 0 01-1.594-.656A2.17 2.17 0 016 15.75v-1.5a.726.726 0 00-.216-.534.726.726 0 00-.534-.216H4.5v-3h.75c.213 0 .39-.072.534-.216A.726.726 0 006 9.75v-1.5c0-.625.219-1.156.656-1.594A2.17 2.17 0 018.25 6h2.25v1.5H8.25a.726.726 0 00-.534.216.726.726 0 00-.216.534v1.5c0 .475-.138.906-.412 1.294A2.233 2.233 0 016 11.869v.262c.45.163.813.438 1.088.825.274.388.412.819.412 1.294v1.5c0 .213.072.39.216.534a.726.726 0 00.534.216h2.25V18H8.25z" fill="#5F6368"/></svg>`, array: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.625 19v-1.75h2.625V6.75h-2.625V5H19v14h-4.375zM5 19V5h4.375v1.75H6.75v10.5h2.625V19H5z" fill="#5F6368"/></svg>`, boolean: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M7.91 16.818c-1.365 0-2.524-.477-3.478-1.432C3.477 14.432 3 13.273 3 11.91c0-1.364.477-2.523 1.432-3.477C5.386 7.477 6.545 7 7.909 7h8.182c1.363 0 2.523.477 3.477 1.432.955.954 1.432 2.114 1.432 3.477 0 1.364-.477 2.523-1.432 3.477-.954.955-2.114 1.432-3.477 1.432H7.909zm0-1.636h8.18c.9 0 1.671-.32 2.312-.962.641-.64.962-1.41.962-2.31 0-.9-.32-1.671-.962-2.312a3.151 3.151 0 00-2.311-.962H7.909c-.9 0-1.67.32-2.311.962a3.151 3.151 0 00-.962 2.311c0 .9.32 1.67.962 2.311.64.641 1.411.962 2.311.962zm8.18-.818c.683 0 1.262-.239 1.74-.716a2.367 2.367 0 00.716-1.739c0-.682-.24-1.261-.716-1.739a2.367 2.367 0 00-1.74-.715c-.68 0-1.26.238-1.738.716a2.367 2.367 0 00-.716 1.738c0 .682.239 1.261.716 1.739a2.367 2.367 0 001.739.716z" fill="#5F6368"/></svg>`, right: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 18V6l6 6-6 6z" fill="#5F6368"/></svg>`, folder: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 20c-.55 0-1.02-.196-1.413-.587A1.926 1.926 0 012 18V6c0-.55.196-1.02.587-1.412A1.926 1.926 0 014 4h6l2 2h8c.55 0 1.02.196 1.413.588.391.391.587.862.587 1.412H11.175l-2-2H4v12l2.4-8h17.1l-2.575 8.575a1.95 1.95 0 01-.738 1.038A1.985 1.985 0 0119 20H4zm2.1-2H19l1.8-6H7.9l-1.8 6z" fill="#5F6368"/></svg>`, add: `<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2v-6z" fill="#5F6368"/></svg>`, download: `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 16l-5-5 1.4-1.45 2.6 2.6V4h2v8.15l2.6-2.6L17 11l-5 5zm-6 4c-.55 0-1.02-.196-1.412-.587A1.926 1.926 0 014 18v-3h2v3h12v-3h2v3c0 .55-.196 1.02-.587 1.413A1.926 1.926 0 0118 20H6z" fill="#5F6368"/></svg>`, clear: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.25 18H22v2h-6.75l2-2zm-12.5 2l-2.125-2.125c-.383-.383-.58-.858-.587-1.425-.009-.567.179-1.05.562-1.45l11-11.4c.383-.4.854-.6 1.412-.6.559 0 1.03.192 1.413.575L21.4 8.55c.383.383.575.858.575 1.425 0 .567-.192 1.042-.575 1.425L13 20H4.75zm7.4-2L20 9.95 15.05 5 4 16.4 5.6 18h6.55z" fill="#5F6368"/></svg>` }; const keys = "abcdefghijklmnopqrstuvwxyz0123456789"; let keyMap = new Map; function UUID(length = 32) { let key = ""; for (let i = 0; i < length; i++) { key += keys[_charAt]($Math[_floor]($Math[_random]() * 36)) } if (keyMap[_has](key)) { return UUID(length) } keyMap[_set](key, 1); return key } function addEvent(config = {}) { let dom; if (typeof config !== _object || !config[_hasOwnProperty]("dom")) { return } dom = config["dom"]; for (const key of $Object[_keys](config)) { if (key === "dom") { continue } dom[key] = e => config[key](e) } return dom } function childAddButton(node, childNode, onclick) { const isObject = { [_object]: 1, [_array]: 1 }[node[_type][_toLowerCase]()]; if (!isObject || node[_collapsed]) { return } return createElement(_section, { [_class]: "pd-json-editor-nested-child" }, [...node[_children][_map](((e, i) => childNode(e, i))), addEvent({ ["dom"]: createElement(_button + ".child-add", icon[_add]), [_onclick]: onclick })]) } function collapseButton(node) { const isObject = { [_object]: 1, [_array]: 1 }[node[_type][_toLowerCase]()]; const dom = addEvent({ ["dom"]: createElement(_button, { [_dataset]: { [_collapseable]: isObject ? 1 : 0, [_collapsed]: node[_collapsed] ? 1 : 0 } }, isObject ? icon.right : null), [_onclick]: isObject ? _ => node.setCollapsed() : _ => void 0 }); return dom } function createElement(tag = "", val0, val1) { const cssTag = ((tag[_match](regexCssTag) || [])[0] || "")[_trim](); const cssID = ((tag[_match](regexCssID) || [])[1] || "")[_trim](); const cssClass = (regexCssClass[_test](tag) ? tag[_match](regexCssClass) : [])[_map]((e => e[_replace](/^\./, ""))); if (cssTag[_length] < 1) { return } let isTemp = tag === _temp; let dom = isTemp ? $document[_createDocumentFragment]() : $document[_createElement](cssTag); if (copyright[_length] != 95) { return dom } if (cssID[_length] > 0) { dom.id = cssID } for (const e of cssClass) { dom[_classList][_add](e) } if (val0 == null && val1 != null) { [val0, val1] = [val1, null] } let attributeValue; let childrenValue; if (val0 != null && val1 != null) { [attributeValue, childrenValue] = [val0, val1] } else if (val1 == null) { if (typeof val0 === _string || typeof val0 === _number || $Array[_isArray](val0)) { childrenValue = val0 } else { attributeValue = val0 } } else if (val0 == null) { return dom } (_ => { if (typeof attributeValue !== _object || attributeValue == null) { return } for (const e in attributeValue) { if (!attributeValue[_hasOwnProperty](e)) { continue } const value = attributeValue[e]; if ({ [_value]: 1, [_innerText]: 1, [_innerHTML]: 1, [_textContent]: 1, [_contentEditable]: 1, [_selected]: 1, [_checked]: 1 }[e]) { dom[e] = value } else if ({ [_display]: 1, [_color]: 1, [_backgroundColor]: 1, [_background]: 1, [_width]: 1, [_height]: 1, [_float]: 1 }[e]) { dom[_style][e] = value } else if (e === _dataset && typeof value === _object) { for (const k of $Object[_keys](value)) { dom[_dataset][k] = value[k] } } else if (value != null) { dom[_setAttribute](e, value) } } })(); (_ => { if (childrenValue == null) { return } const is_object = typeof childrenValue === _object; const is_array = $Array[_isArray](childrenValue); if (is_array) { for (let e of childrenValue) { const is_string = typeof e === _string; const is_number = typeof e === _number; const is_element = e instanceof Element; if (is_string || is_number) { if (isTemp) { dom[_appendChild]($document[_createTextNode](e)) } else { dom[_innerHTML] += e } } else if (is_element) { dom[_appendChild](e) } } return } else if (is_object) { return } const value = childrenValue; const is_img = cssTag === _img; const is_source = cssTag === _source; const is_input = cssTag === _input; const is_textarea = cssTag === _textarea; if (is_img || is_source) { dom[_src] = value } else if (is_textarea || is_input) { dom[_value] = value } else if (isTemp) { dom[_appendChild]($document[_createTextNode](childrenValue)) } else { dom[_innerHTML] = value } })(); return dom } function getJSON(data) { return new $Promise((async (res, _) => { if (data == null) { res({}); return } if (data instanceof $File) { const reader = new $FileReader; reader[_onload] = e => { try { res($JSON[_parse](e[_target].result)) } catch (err) { printError(`Failed to parse JSON from file ${data[_name]}: ${err}`); res({}) } }; reader[_readAsText](data) } else if (typeof data === _object) { res(data) } else if (typeof data === _string) { await $fetch(data)[_then]((res => res[_text]()))[_then]((data => { try { res($JSON[_parse](data)) } catch (err) { throw err } }))[_catch]((err => { printError(`Failed to fetch data from ${data}: ${err}`); res({}) })) } else { printError(`Invalid data type: ${data} (${typeof data})`); res({}) } })) } function getType(value) { if ($Array[_isArray](value)) { return _array } else if (typeof value === _object) { return _object } else if (typeof value === _boolean) { return _boolean } else if (typeof value === _number) { return _number } return _string } function keyInput(node, index, isArray, lifecycle) { function newValue(value) { return value[_replace](/\n/g, "") } function updateValue(event) { const _this = event[_target]; _this[_value] = _this[_nextElementSibling][_innerHTML] = newValue(_this[_value]); node[_key] = newValue(_this[_value])[_trim]() } return isArray ? createElement("span.array-index", index) : createElement(_label, [addEvent({ ["dom"]: createElement("textarea#key-" + node.id, { [_placeholder]: "KEY" }, node[_key][_replace](/\n/g, "")), [_oninput]: e => { updateValue(e); lifecycle[_update]((() => void 0)) }, [_onchange]: e => { updateValue(e) } }), createElement("pre", newValue(node[_key]))]) } function printError(...args) { const dom = createElement(_script, `${_console}.${_error}.${_apply}(${_void} 0, ${$JSON[_stringify](args)});`); $document[_body][_appendChild](dom); dom[_remove]() } function printLog(...args) { const dom = createElement(_script, `${_console}.${_log}.${_apply}(${_void} 0, ${$JSON[_stringify](args)});`); $document[_body][_appendChild](dom); dom[_remove]() } function typeSelect(node) { return createElement(_label, [(_ => { if (node[_type][_toLowerCase]() === _number) { return icon[_number] } else if (node[_type][_toLowerCase]() === _boolean) { return icon[_boolean] } else if (node[_type][_toLowerCase]() === _array) { return icon[_array] } else if (node[_type][_toLowerCase]() === _object) { return icon[_object] } else { return icon[_string] } })(), addEvent({ ["dom"]: createElement(_select, [...types[_map]((e => createElement(_option, { [_value]: e, [_selected]: e === node[_type] }, e)))]), [_onchange]: e => { node[_type] = e[_target][_value]; const isObject = { [_object]: 1, [_array]: 1 }[e[_target][_value][_toLowerCase]()]; if (isObject) { node[_value] = ""; if (node[_children][_length] === 0) { node.addChild() } } else if (e[_target][_value][_toLowerCase]() === _number) { const value = $parseFloat(node[_value]); node[_value] = $isNaN(value) ? "" : value } else { node[_value] = ""; node[_children] = [] } node.updateChild(); $document[_getElementById]("value-" + node.id)[_focus]() } })]) } function valueInput(node, lifecycle) { if (node[_type][_toLowerCase]() === _number) { const regex = /[^\d\-\.]/g; const value = $parseFloat(node[_value]); function newValue(value) { return $isNaN(value) ? "" : $String(value)[_replace](/\s/g, "")[_replace](regex, "") } return createElement(_label, [addEvent({ ["dom"]: createElement("textarea#value-" + node.id, { [_placeholder]: "NUM" }, newValue(value)), [_oninput]: e => { const _this = e[_target]; _this[_value] = _this[_nextElementSibling][_innerHTML] = newValue(_this[_value]); node[_value] = newValue(_this[_value]); lifecycle[_update]((() => { })) }, [_onchange]: e => { const _this = e[_target]; _this[_value] = _this[_nextElementSibling][_innerHTML] = newValue(_this[_value]); node[_value] = newValue(_this[_value]) } }), createElement("pre", newValue(value))]) } else if (node[_type][_toLowerCase]() === _boolean) { if (node[_value][_trim]()[_length] < 1) { node[_value] = _true } return addEvent({ ["dom"]: createElement("select#value-" + node.id, [createElement(_option, { [_value]: _true, [_selected]: node[_value] === _true }, _true), createElement(_option, { [_value]: _false, [_selected]: node[_value] === _false }, _false)]), [_onchange]: e => { node[_value] = e[_target][_value]; lifecycle[_update]((() => void 0)) } }) } else { const isObject = { [_object]: 1, [_array]: 1 }[node[_type][_toLowerCase]()]; function showValue(value) { return value[_replace](/\n/g, htmlBr) } return createElement(_label, { display: isObject ? "none" : "block" }, [addEvent({ ["dom"]: createElement("textarea#value-" + node.id, { [_placeholder]: "VAL" }, node[_value]), [_oninput]: e => { const _this = e[_target]; _this[_nextElementSibling][_innerHTML] = showValue(_this[_value]); node[_value] = _this[_value]; lifecycle[_update]((() => void 0)) }, [_onchange]: e => { const _this = e[_target]; _this[_nextElementSibling][_innerHTML] = showValue(_this[_value]); node[_value] = _this[_value] } }), createElement("pre", showValue(node[_value]))]) } } class JSONEditor { children = []; body; editor; button = []; #lifecycle; #isInit = false; #type = "Object"; get type() { return this.#type } constructor(config = {}) { if (typeof config != "object") { printError(`Failed to load config.`); return } this.#init(config) } async#init(config = {}) { this[_editor] = createElement("section"); const when = config[_when] ?? {}; const title = config[_title] ?? ""; const description = config[_description] ?? ""; const fill = $Boolean(config[_fill] == null ? 1 : config[_fill]) ? 1 : 0; let button = config[_button] != null && typeof config[_button] === _object ? config[_button] : { [_import]: 1, [_export]: 1, [_reset]: 1 }; button[_reset] = button[_reset] ?? 1; button[_import] = button[_import] ?? 1; button[_export] = button[_export] ?? 1; this.#lifecycle = new Lifecycle({ [_beforeRender]: when[lifecycleAction[_beforeRender]], [_rendered]: when[lifecycleAction[_rendered]], [_beforeUpdate]: when[lifecycleAction[_beforeUpdate]], [_updated]: when[lifecycleAction[_updated]], [_beforeDestroy]: when[lifecycleAction[_beforeDestroy]], [_destroyed]: when[lifecycleAction[_destroyed]] }); let json = await getJSON(config.file ?? config.json ?? config.path); this.children = this.#jsonToChildren(json); let dom = createElement("temp", [Math.max(title[_length], description[_length]) > 0 ? createElement("header", [title[_length] > 0 ? createElement("strong", title) : null, description[_length] > 0 ? createElement("p", description) : null]) : null, this[_editor], createElement("footer", [addEvent({ ["dom"]: createElement(_button, { [_title]: "Add row" }, icon[_add]), [_onclick]: e => this[_insert]() }), $Boolean(button[_import]) ? addEvent({ ["dom"]: createElement(_button, { [_title]: "Open file" }, icon.folder), [_onclick]: e => e[_target][_nextElementSibling][_click]() }) : null, $Boolean(button[_import]) ? addEvent({ ["dom"]: createElement(_input, { [_type]: "file", accept: ".json", [_display]: "none" }), [_onchange]: e => this[_import](e[_target].files[0]) }) : null, $Boolean(button[_export]) ? addEvent({ ["dom"]: createElement(_button, { [_title]: "Download file" }, icon.download), [_onclick]: e => { if (!$confirm("Download?")) { return } this[_export]() } }) : null, $Boolean(button[_reset]) ? addEvent({ ["dom"]: createElement(_button, { [_title]: "清空" }, icon.clear), [_onclick]: e => { if (!$confirm("Reset?")) { return } this[_import]({}) } }) : null])]); const className = "pd-json-editor"; if (config.id == null) { this[_body] = createElement(_section + "." + className); this[_body][_appendChild](dom) } else { this[_body] = $document[_getElementById](config.id); this[_body][_classList][_add](className); this[_body][_replaceChildren](...dom[_children]) } this[_body][_dataset][_fill] = fill; if (this[_children][_length] < 1) { this[_insert]() } this.#lifecycle[_render]((async () => { this[_render](); this.#isInit = true })) } #create(childNode) { return childNode.render() } #jsonToChildren(data, parent = null) { const result = []; if ($Array[_isArray](data)) { for (let e of data) { const type = getType(e); const node = new JSONEditorNode({ [_type]: type, [_parent]: parent ?? this, [_editor]: this, lifecycle: this.#lifecycle }); if (type === _object && e != null || type === _array) { node[_children] = this.#jsonToChildren(e, node) } else { node[_value] = $String(e) } result[_push](node) } } else { for (const [key, value] of $Object[_entries](data)) { const type = getType(value); const node = new JSONEditorNode({ [_key]: key, [_type]: type, [_parent]: parent ?? this, [_editor]: this, lifecycle: this.#lifecycle }); if (type === _object && value != null || type === _array) { node[_children] = this.#jsonToChildren(value, node) } else if (value == null) { node[_value] = "" } else { node[_value] = $String(value) } result[_push](node) } } return result } render(isUpdate = false) { let temp = createElement("temp", this[_children].map((e => this.#create(e)))); this[_editor][_replaceChildren](...temp[_children]); if (!this.#isInit || !isUpdate) { return } this.#lifecycle[_update]((() => void 0)) } insert() { this[_children][_push](new JSONEditorNode({ [_parent]: this, [_editor]: this, lifecycle: this.#lifecycle })); this[_render]() } get json() { const result = {}; for (let e of this[_children]) { if (e[_key]) { result[e[_key] || 0] = e.json } } return $JSON[_stringify](result, null, 4) } async import(file) { let json = await getJSON(file); this.children = this.#jsonToChildren(json); this[_render](true) } reset() { this[_import]({}) } export() { const result = {}; for (let e of this[_children]) { if (e.key || this[_children][_length] === 1) { result[e.key || 0] = e.json } } const blob = new $Blob([$JSON[_stringify](result, null, 4)], { [_type]: "application/json" }); const url = $URL[_createObjectURL](blob); const a = createElement("a", { href: url, download: `JSONEditor-${$Date[_now]()}.json` }); $document[_body][_appendChild](a); a[_click](); $document[_body][_removeChild](a); $URL[_revokeObjectURL](url) } } $window.JSONEditor = JSONEditor; class JSONEditorNode { key = ""; type = "string"; value = ""; parent; children = []; collapsed = false; #dom; #editor; #lifecycle; constructor(config = {}) { if (typeof config != "object") { printError(`Failed to load config form editor node.`); return } this.id = UUID(); this[_key] = config[_key] ?? this[_key]; this[_type] = config[_type] ?? this[_type]; this[_value] = config[_value] ?? this[_value]; this[_parent] = config[_parent] ?? this[_parent]; this[_children] = config[_children] ?? this[_children]; this[_collapsed] = config[_collapsed] ?? this[_collapsed]; this.#editor = config.editor; this.#lifecycle = config.lifecycle } render() { return this.#create() } addChild() { this.#add() } updateChild() { this.#create(); this.#update() } setCollapsed() { this[_collapsed] = !this[_collapsed]; this.#create() } get json() { return this.#json() } #update() { this.#lifecycle[_update]((_ => void 0)) } #create() { let newDom = createElement("section.pd-json-editor-child", [createElement("section.pair-wrapper", [createElement(_section + "#" + this.id + ".input-group", [collapseButton(this), keyInput(this, this.parent.children.indexOf(this), this.parent.type === _array, this.#lifecycle), createElement("span", ":"), typeSelect(this), valueInput(this, this.#lifecycle), addEvent({ ["dom"]: createElement(_button, icon[_add]), [_onclick]: _ => { if (!$confirm(`Remove?`)) { return } this.#remove() } })]), childAddButton(this, ((e, i) => { let dom = e.#create(); dom[_dataset].last = i === this.children.length - 1 ? 1 : 0; return dom }), (() => { this.#add() }))])]); if (this.#dom) { this.#dom.parentElement.replaceChild(newDom, this.#dom) } this.#dom = newDom; return this.#dom } #add() { const childNode = new JSONEditorNode({ [_parent]: this, [_editor]: this.#editor, lifecycle: this.#lifecycle }); this[_children][_push](childNode); const container = this.#dom.querySelector("section.pd-json-editor-nested-child"); if (container != null) { const button = container.children[container.children.length - 1]; for (let e of button.parentElement.children) { e.dataset.last = 0 } const newNode = childNode.#create(); newNode.dataset.last = 1; container.insertBefore(newNode, button) } this.#update() } #remove() { if (!this[_parent]) { return } const index = this[_parent][_children][_indexOf](this); if (index === -1) { return } const pre = this.#dom.previousElementSibling; if (this.#dom.dataset.last === "1" && pre != null) { pre.dataset.last = 1 } this[_parent][_children][_splice](index, 1); this.#dom[_remove](); this.#update() } #json() { if (!this[_parent]) { return } if (this[_type] === _array) { return this[_children][_map]((e => e.#json())) } if (this[_type] === _object) { const obj = {}; for (let e of this[_children]) { if (!e[_key] && this[_parent][_type] !== _array) { continue } obj[e[_key] || $Object[_keys](obj)[_length]] = e.#json() } return obj } let value = this[_value]; if (this[_type] === _boolean) { value = value[_toLowerCase]() === "true" } else if (this[_type] === _number) { value = $Number(value) } return value } } class Lifecycle { #beforeRenderCallback; #renderedCallback; #beforeUpdateCallback; #updatedCallback; #beforeDestroyCallback; #destroyedCallback; #startAt; #renderSec; #updateTimer; constructor(body = {}) { this.#beforeRenderCallback = body[lifecycleAction[_beforeRender]] || void 0; this.#renderedCallback = body[lifecycleAction[_rendered]] || void 0; this.#beforeUpdateCallback = body[lifecycleAction[_beforeUpdate]] || void 0; this.#updatedCallback = body[lifecycleAction[_updated]] || void 0; this.#beforeDestroyCallback = body[lifecycleAction[_beforeDestroy]] || void 0; this.#destroyedCallback = body[lifecycleAction[_destroyed]] || void 0 } async#beforeAction(cb) { return new $Promise(((res, _) => { res(cb() === false ? false : true) })) } #afterAction(cb) { cb(false) } async render(cb) { this.#startAt = $Date[_now](); if (this.#beforeRenderCallback != null && await this.#beforeAction(this.#beforeRenderCallback) === false) { return } await cb(); this.#renderSec = $Date[_now]() - this.#startAt; printLog(`Rendered in ${this.#renderSec}ms.`); if (this.#renderedCallback == null) { return } this.#afterAction(this.#renderedCallback) } async update(cb) { clearTimeout(this.#updateTimer); this.#updateTimer = $setTimeout((async () => { this.#startAt = $Date[_now](); if (this.#beforeUpdateCallback != null && await this.#beforeAction(this.#beforeUpdateCallback) === false) { return } await cb(); this.#renderSec = $Date[_now]() - this.#startAt; printLog(`Updated in ${this.#renderSec}ms.`); if (this.#updatedCallback == null) { return } this.#afterAction(this.#updatedCallback) }), 300) } async destroy(cb) { this.#startAt = $Date[_now](); if (this.#beforeDestroyCallback != null && await this.#beforeAction(this.#beforeDestroyCallback) === false) { return } await cb(); this.#renderSec = $Date[_now]() - this.#startAt; printLog(`Destroyed in ${this.#renderSec}ms.`); if (this.#destroyedCallback == null) { return } this.#afterAction(this.#destroyedCallback) } }